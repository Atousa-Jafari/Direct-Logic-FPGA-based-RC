# -*- coding: utf-8 -*-
"""DSP_Based_Generator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gKwFkUT-6lO4_Tbv-BB7s3mFur6LyX66
"""

#pip install hyperopt jupyter matplotlib pandas requests reservoirpy scikit-learn seaborn brevitas fxpmath

import rc_model_generation_dsp
import os
import numpy as np




def generate_verilog_code(num_reservoir_neurons, input_weight, reservoir_state, a_scaled, b_scaled, c_scaled, d_scaled, reservoir_weight, output_weight,bit_width):
    code = f"""`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company:
// Engineer:
//
// Create Date: 03/04/2024 09:10:17 AM
// Design Name:
// Module Name: EchoStateNetwork
// Project Name:
// Target Devices:
// Tool Versions:
// Description:
//
// Dependencies:
//
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
//
//////////////////////////////////////////////////////////////////////////////////

(* use_dsp="yes" *)module ESN_Generator_V2(
    input clk,
    input signed [{bit_width-1}:0] input_data,
    output wire signed [{4*bit_width-1}:0] output_data
);
parameter num_reservoir_neurons = {num_reservoir_neurons};

// Input layer
reg signed [{bit_width-1}:0] input_weight [0: num_reservoir_neurons-1];
initial {{
"""
    for i in range(num_reservoir_neurons):
      if i<num_reservoir_neurons-1:
        code += f"input_weight[{i}],\n"
      else:
        code += f"input_weight[{i}]\n"
    code += """} = {
"""
    for i in range(num_reservoir_neurons):
      if i<num_reservoir_neurons-1:
        if (input_weight[i][0]<0):
          code += f"-{bit_width}'sd{(input_weight[i][0])*-1},\n"
        else:
          code += f"{bit_width}'sd{input_weight[i][0]},\n"

      else:
        if (input_weight[i]<0):
          code += f"-{bit_width}'sd{(input_weight[i][0])*-1}\n"
        else:
         code += f"{bit_width}'sd{input_weight[i][0]}\n"
    code +="""};

    // Reservoir layer
    """
    code += f"reg signed [{2*bit_width-1}:0] a_scaled = {2*bit_width}'d{a_scaled};\n"
    code += f"reg signed [{2*bit_width-1}:0] b_scaled = {2*bit_width}'d{b_scaled};\n"
    code += f"reg signed [{2*bit_width-1}:0] c_scaled = {2*bit_width}'d{c_scaled};\n"
    code += f"reg signed [{2*bit_width-1}:0] d_scaled = {2*bit_width}'d{d_scaled};\n"
    code += f"reg signed [{4*bit_width-1}:0] reservoir_state [0: num_reservoir_neurons-1];\n"
    code += """initial {
"""
    for i in range(num_reservoir_neurons):
      if i<num_reservoir_neurons-1:
        code += f"reservoir_state[{i}],\n"
      else:
        code += f"reservoir_state[{i}]\n"
    code += """} = {
"""
    for i in range(num_reservoir_neurons):
      if i<num_reservoir_neurons-1:
        if (reservoir_state[0][i]<0):
            code += f"-{4*bit_width}'sd{-1*(reservoir_state[0][i])},\n"
        else:
            code += f"{4*bit_width}'sd{reservoir_state[0][i]},\n"

      else:
        if (reservoir_state[0][i]<0):
         code += f"-{4*bit_width}'sd{-1*(reservoir_state[0][i])}\n"
        else:
         code += f"{4*bit_width}'sd{reservoir_state[0][i]}\n"
    code += """};"""

    code +=f"""reg signed [{bit_width-1}:0] reservoir_weight [0: num_reservoir_neurons-1][0: num_reservoir_neurons-1];"""
    code += """initial {
"""
    for i in range(num_reservoir_neurons):
        code += """{"""
        for j in range(num_reservoir_neurons):
          if j<num_reservoir_neurons-1:
            code += f"reservoir_weight[{i}][{j}],\n"
          else:
            code += f"reservoir_weight[{i}][{j}]\n"
        if i<num_reservoir_neurons-1:
          code += """},\n"""
        else:
          code += """}\n"""
    code += """} = {
"""
    for i in range(num_reservoir_neurons):
        code += """{"""
        for j in range(num_reservoir_neurons):
          if j<num_reservoir_neurons-1:
            if(reservoir_weight[i][j]<0):
              code += f"-{bit_width}'sd{-1*(reservoir_weight[i][j])},\n"
            else:
              code += f"{bit_width}'sd{reservoir_weight[i][j]},\n"

          else:
            if(reservoir_weight[i][j]<0):
                code += f"-{bit_width}'sd{-1*(reservoir_weight[i][j])}\n"
            else:
                code += f"{bit_width}'sd{reservoir_weight[i][j]}\n"
        if i<num_reservoir_neurons-1:
          code += """},\n"""
        else:
          code += """}\n"""
    code += """};
// Output layer
"""
    code +=f"""reg signed [{bit_width-1}:0] output_weight [0: num_reservoir_neurons-1];"""
    code += """initial {
	"""
    for i in range(num_reservoir_neurons):
      if i<num_reservoir_neurons-1:
        code += f"output_weight[{i}],\n"
      else:
        code += f"output_weight[{i}]\n"
    code += """} = {
"""




    for i in range(num_reservoir_neurons):
      if i<num_reservoir_neurons-1:
        if(output_weight[i][0]<0):
          code += f"-{bit_width}'sd{abs(output_weight[i][0])},\n"
        else:
          code += f"{bit_width}'sd{output_weight[i][0]},\n"
      else:
        if(output_weight[i][0]<0):
          code += f"-{bit_width}'sd{abs(output_weight[i][0])}\n"
        else:
          code += f"{bit_width}'sd{output_weight[i][0]}\n"
    code += """};"""
    code += f""""
  // Scaling factors and zero point
  reg signed [{4*bit_width-1}:0] scale = {4*bit_width}'b00000000000000010101101110001010;

  reg signed [{4*bit_width-1}:0] input_sum_parallel [0: num_reservoir_neurons-1];
  reg signed [{4*bit_width-1}:0] reservoir_sum_parallel [0: num_reservoir_neurons-1];
  reg signed [{4*bit_width-1}:0] output_sum;
  integer i,j,k,x,y,t,m,n,p,q;

  reg signed [{4*bit_width-1}:0] reg_input [0: num_reservoir_neurons-1];
  reg signed [{4*bit_width-1}:0] reg_reservoir [0: num_reservoir_neurons-1];
  // ESN logic
  always @(posedge clk) begin

      for (i = 0; i < num_reservoir_neurons; i = i + 1) begin
        input_sum_parallel[i] = input_data * input_weight[i];
        reservoir_sum_parallel[i]= 0;
      end

      for (j = 0; j < num_reservoir_neurons; j = j + 1) begin
        for (k = 0; k < num_reservoir_neurons; k = k + 1) begin
          reservoir_sum_parallel[j] = reservoir_sum_parallel[j] + (reservoir_state[k] * reservoir_weight[k][j]);
        end
      end


      for (m = 0; m < num_reservoir_neurons; m = m + 1) begin
          reg_input[m] = 0;
          if (input_sum_parallel[m] < a_scaled) begin
              reg_input[m] = a_scaled;
          end
          else if (input_sum_parallel[m] > b_scaled) begin
              reg_input[m] = b_scaled;
          end
          else begin
              reg_input[m] = input_sum_parallel[m];
          end
      end

      for (p = 0; p < num_reservoir_neurons; p = p + 1) begin
          reg_reservoir[p] = 0;
          if (reservoir_sum_parallel[p] < c_scaled) begin
              reg_reservoir[p] = c_scaled;
          end
          else if (reservoir_sum_parallel[p] > d_scaled) begin
              reg_reservoir[p] = d_scaled;
          end
          else begin
              reg_reservoir[p] = reservoir_sum_parallel[p];
          end
      end

      for (k = 0; k < num_reservoir_neurons; k = k + 1) begin
          reg_input[j]=reg_input[j]+16'd1628;
          reg_input[k] <= reg_input[k] >> {bit_width};
          reg_reservoir[k]=reg_reservoir[k]+16'd17641;
          reg_reservoir[k]<= reg_reservoir[k] >> {bit_width};
      end

      for (y = 0; y < num_reservoir_neurons; y = y + 1) begin
          reservoir_state[y] <= reg_reservoir[y] + reg_input[y];

      end

      // Output calculation
       // Wider format for accumulation
      output_sum = 0;



      for (t = 0; t < num_reservoir_neurons; t = t + 1) begin
        output_sum = output_sum +(reservoir_state[t] * output_weight[t]);
      end




    end
    //assign output_data = output_sum * scale;
    assign output_data = output_sum ;
endmodule
"""
    return code



verilog_code= generate_verilog_code(rc_model_generation_dsp.N, rc_model_generation_dsp.int_Win, rc_model_generation_dsp.state_int,rc_model_generation_dsp.a_scaled, rc_model_generation_dsp.b_scaled, rc_model_generation_dsp.c_scaled, rc_model_generation_dsp.d_scaled, rc_model_generation_dsp.int_Wr, rc_model_generation_dsp.Wout_quantized,rc_model_generation_dsp.bit_width)
output_path = os.path.join(os.path.dirname(__file__), "DSP_200_8.v")
with open(output_path, "w") as verilog_file:
    verilog_file.write(verilog_code)